---
layout: post
title: Java异常处理
categories: Java
description: Java异常总结
keywords: Java, Exception, Error
---

Java提供的异常处理机制能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。

这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。



## 什么是异常？

> 异常是指阻止当前方法或者作用域继续执行的问题。

在当前的环境下程序无法正常运行下去，程序就会从当前环境中跳出，并抛出异常。抛出异常后。

- new创建一个异常对象。
- 在产生异常的位置终止程序，并且从当前环境中弹出对异常对象的引用
- 异常处理机制就会接管程序，并开始寻找一个恰当的地方（异常处理程序）来继续执行程序。
  - 负责将程序从错误状态恢复，以使程序要么换一种方法执行，要么继续执行下去。

## Java异常体系

![](/images/posts/Java/Exception.png)

### Throwable

Throwable是java语言中所有错误和异常的超类，它有两个子类：Error、Exception。

- Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。

#### Error

Error是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM出现的问题。

- 这些异常发生时，JVM一般会选择线程终止。
- 这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，程序也不应该试图去处理Error。

#### Exception

Exception是程序可以处理的异常。

### 分类

Java的异常(包括Exception和Error)分为**可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）**。

#### CheckedException

编译器要求必须处置CheckedException。

-  除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。


- CheckException发生在编译阶段，必须要使用try…catch（或者throws子句声明抛出）否则编译不通过。

#### UncheckedException

UncheckedException发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的。

- 包括运行时异常（RuntimeException与其子类）和错误（Error）。

### 如何自定义异常？

Java允许我们自定义异常来表现程序中可能会遇到的特定问题。步骤如下：

1. 定义一个类继承Throwable或其子类。
2. 添加构造方法(也可以不用添加，使用默认构造方法)。
3. 在某个方法类抛出该异常。
4. 捕捉该异常。

## 如何处理异常？

Java 的异常处理机制为：抛出异常，捕捉异常。

### 抛出异常

当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。

- 运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。
- 对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。

#### 如何抛出异常？

##### throws

如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用throws子句来声明抛出异常。

- throws语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是Exception异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。
- 如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。
- 必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误
- 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。
- 调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。

##### throw

**throw**关键字可以抛出一个异常，无论它是新实例化的还是刚捕获到的。

### 捕获异常

在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。

- 捕捉异常通过try-catch语句或者try-catch-finally语句实现。

#### try-catch-finally

##### **try 块**

用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。

##### **catch 块**

用于处理try捕获到的异常。

- 多重捕获块中JVM会把实际抛出的异常对象**依次**和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，**不会**再执行其他的 catch代码块

##### **finally 块**

无论是否捕获或处理异常，finally块里的语句都会被执行。

- 当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。
- 当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行。
- 在以下4种特殊情况下，finally块不会被执行：
  1. 在finally语句块中发生了异常。
  2. 在前面的代码中用了System.exit()退出程序。
  3. 程序所在的线程死亡。
  4. 关闭CPU。





